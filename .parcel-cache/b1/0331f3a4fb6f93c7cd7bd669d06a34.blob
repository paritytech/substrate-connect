var _buffer = require('buffer');
var _compatNodejsJs = require('./compat-nodejs.js');
var _bindingsSmoldotJsJs = require('./bindings-smoldot-js.js');
var _bindingsWasiJs = require('./bindings-wasi.js');
var _autogenWasmJs = require('./autogen/wasm.js');
// This variable represents the state of the worker, and serves three different purposes:
// 
// - At initialization, it is set to `null`.
// - Once the first message, containing the configuration, has been received from the parent, it
// becomes an array filled with JSON-RPC requests that are received while the Wasm VM is still
// initializing.
// - After the Wasm VM has finished initialization, contains the `WebAssembly.Instance` object.
// 
let state = null;
// Set to `true` once `throw` has been called.
// As documented, after the `throw` function has been called, it is forbidden to call any
// further function of the Wasm virtual machine. This flag is used to enforce this.
let has_thrown = false;
const startInstance = async config => {
  const chain_spec = config.chain_spec;
  const database_content = config.database_content;
  const relay_chain_spec = config.relay_chain_spec;
  const max_log_level = config.max_log_level;
  // The actual Wasm bytecode is base64-decoded from a constant found in a different file.
  // This is suboptimal compared to using `instantiateStreaming`, but it is the most
  // cross-platform cross-bundler approach.
  let wasm_bytecode = new Uint8Array(_buffer.Buffer.from(_autogenWasmJs.default, 'base64'));
  // Used to bind with the smoldot-js bindings. See the `bindings-smoldot-js.js` file.
  let smoldot_js_config = {
    onTerminated: () => has_thrown = true,
    json_rpc_callback: data => {
      // `compat.postMessage` is the same as `postMessage`, but works across environments.
      _compatNodejsJs.postMessage({
        kind: 'jsonrpc',
        data
      });
    },
    database_save_callback: data => {
      // `compat.postMessage` is the same as `postMessage`, but works across environments.
      _compatNodejsJs.postMessage({
        kind: 'database',
        data
      });
    }
  };
  let {bindings: smoldot_js_bindings, terminate} = _bindingsSmoldotJsJs.default(smoldot_js_config);
  // Used to bind with the Wasi bindings. See the `bindings-wasi.js` file.
  let wasi_config = {
    onTerminated: () => {
      has_thrown = true;
      terminate();
    }
  };
  // Start the Wasm virtual machine.
  // The Rust code defines a list of imports that must be fulfilled by the environment. The second
  // parameter provides their implementations.
  let result = await WebAssembly.instantiate(wasm_bytecode, {
    // The functions with the "smoldot" prefix are specific to smoldot.
    "smoldot": smoldot_js_bindings,
    // As the Rust code is compiled for wasi, some more wasi-specific imports exist.
    "wasi_snapshot_preview1": _bindingsWasiJs.default(wasi_config)
  });
  smoldot_js_config.instance = result.instance;
  wasi_config.instance = result.instance;
  let chain_spec_len = _buffer.Buffer.byteLength(chain_spec, 'utf8');
  let chain_spec_ptr = result.instance.exports.alloc(chain_spec_len);
  _buffer.Buffer.from(result.instance.exports.memory.buffer).write(chain_spec, chain_spec_ptr);
  let database_len = database_content ? _buffer.Buffer.byteLength(database_content, 'utf8') : 0;
  let database_ptr = database_len != 0 ? result.instance.exports.alloc(database_len) : 0;
  if (database_len != 0) {
    _buffer.Buffer.from(result.instance.exports.memory.buffer).write(database_content, database_ptr);
  }
  let relay_chain_spec_len = relay_chain_spec ? _buffer.Buffer.byteLength(relay_chain_spec, 'utf8') : 0;
  let relay_chain_spec_ptr = relay_chain_spec_len != 0 ? result.instance.exports.alloc(relay_chain_spec_len) : 0;
  if (relay_chain_spec_len != 0) {
    _buffer.Buffer.from(result.instance.exports.memory.buffer).write(relay_chain_spec, relay_chain_spec_ptr);
  }
  try {
    result.instance.exports.init(chain_spec_ptr, chain_spec_len, database_ptr, database_len, relay_chain_spec_ptr, relay_chain_spec_len, max_log_level);
    state.forEach(json_rpc_request => {
      let len = _buffer.Buffer.byteLength(json_rpc_request, 'utf8');
      let ptr = result.instance.exports.alloc(len);
      _buffer.Buffer.from(result.instance.exports.memory.buffer).write(json_rpc_request, ptr);
      result.instance.exports.json_rpc_send(ptr, len);
    });
    state = result.instance;
  } catch (error) {
    has_thrown = true;
    terminate();
    throw error;
  }
};
// `compat.setOnMessage` is the same as `onmessage = ...`, but works across environments.
_compatNodejsJs.setOnMessage(message => {
  // See the documentation of the `state` variable for information.
  if (state == null) {
    state = [];
    startInstance(message);
  } else if (Array.isArray(state)) {
    // A JSON-RPC request has been received while the Wasm VM is still initializing. Queue it
    // for when initialization is over.
    state.push(message);
  } else {
    if (has_thrown) {
      return;
    }
    let len = _buffer.Buffer.byteLength(message, 'utf8');
    let ptr = state.exports.alloc(len);
    _buffer.Buffer.from(state.exports.memory.buffer).write(message, ptr);
    state.exports.json_rpc_send(ptr, len);
  }
});
