var _parcelHelpers = require("@parcel/transformer-js/lib/esmodule-helpers.js");
_parcelHelpers.defineInteropFlag(exports);
_parcelHelpers.export(exports, "SmoldotError", function () {
  return SmoldotError;
});
_parcelHelpers.export(exports, "start", function () {
  return start;
});
var _compatNodejsJs = require('./compat-nodejs.js');
class SmoldotError extends Error {
  constructor(message) {
    super(message);
  }
}
async function start(config) {
  if (Object.prototype.toString.call(config.chain_spec) !== '[object String]') throw new SmoldotError('config must include a string chain_spec');
  // The actual execution of Smoldot is performed in a worker thread.
  // 
  // The line of code below (`new Worker(...)`) is designed to hopefully work across all
  // platforms. It should work in NodeJS, browsers, webpack
  // (https://webpack.js.org/guides/web-workers/), and parcel
  // (https://github.com/parcel-bundler/parcel/pull/5846)
  const worker = new _compatNodejsJs.Worker(require("./worker.js"));
  // The worker can send us either a database save message, or a JSON-RPC answer.
  _compatNodejsJs.workerOnMessage(worker, message => {
    if (message.kind == 'jsonrpc') {
      if (config.json_rpc_callback) config.json_rpc_callback(message.data);
    } else if (message.kind == 'database') {
      if (config.database_save_callback) config.database_save_callback(message.data);
    } else {
      console.error('Unknown message type', message);
    }
  });
  // The first message expected by the worker contains the configuration.
  worker.postMessage({
    chain_spec: config.chain_spec,
    database_content: config.database_content,
    relay_chain_spec: config.relay_chain_spec,
    // Maximum level of log entries sent by the client.
    // 0 = Logging disabled, 1 = Error, 2 = Warn, 3 = Info, 4 = Debug, 5 = Trace
    max_log_level: config.max_log_level || 5
  });
  // After the initialization message, all further messages expected by the worker are JSON-RPC
  // requests.
  return {
    send_json_rpc: request => {
      worker.postMessage(request);
    },
    terminate: () => {
      worker.terminate();
    }
  };
}
